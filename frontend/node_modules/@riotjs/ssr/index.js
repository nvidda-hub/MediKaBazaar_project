'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

require('pirates');
require('@riotjs/compiler');
require('@babel/core');
var basicHTML = require('basichtml');
var riot = require('riot');
var curry = require('curri');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var basicHTML__default = /*#__PURE__*/_interopDefaultLegacy(basicHTML);
var curry__default = /*#__PURE__*/_interopDefaultLegacy(curry);

// init basic HTML

// make the Node property global
global.Node = basicHTML__default['default'].Node;

basicHTML__default['default'].init({});

const {CSS_BY_NAME} = riot.__.cssManager;
const DOCTYPE_DECLARATION = '<!doctype html>';
const INPUT_ELEMENTS_SELECTOR = 'input,textarea,select,option';
const INPUT_PASSWORD_TYPE = 'password';
const ATTRIBUTE_TYPE_NAME = 'type';
const VALUE_ATTRIBUTE = 'value';

// check if a DOM node has the attribute type='password'
const hasPasswordAttributeType = el => el.attributes.some(attr => attr.name === ATTRIBUTE_TYPE_NAME && attr.value === INPUT_PASSWORD_TYPE);

/**
 * Set the value attribute of all the inputs
 * @param {HTMLElement} element - root node
 * @return {HTMLElement[]} list of the matched input elements
 */
function setUserInputAttributes(element) {
  return element.$$(INPUT_ELEMENTS_SELECTOR).map(el => {
    const value = hasPasswordAttributeType(el) ? '' : el.value;
    el.setAttribute(VALUE_ATTRIBUTE, value || '');

    return el
  })
}

/**
 * Create the renderer function that can produce different types of output from the DOM rendered
 * @param   {Function} renderer - rendering function
 * @param   {string} tagName - tag name of the root node
 * @param   {RiotComponentShell} componentAPI - component shell object
 * @param   {Object} props - initial props
 * @returns {*} output generated by the renderer function
 */
function createRenderer(
  renderer,
  tagName,
  componentAPI,
  props = {}
) {
  const isRootNode = tagName === 'html';
  const root = document.createElement(tagName);
  const element = riot.component(componentAPI)(root, {
    ...props,
    isServer: true
  });
  const dispose = () => {
    // unmount the component
    element.unmount();
    // remove the old stored css
    CSS_BY_NAME.clear();
  };

  //reflect input value prop to attribute
  setUserInputAttributes(element);

  return renderer({
    // serialize the component outer html
    getHTML: () => `${isRootNode ? DOCTYPE_DECLARATION : ''}${root.outerHTML}`,
    dispose,
    element,
    // serialize all the generated css
    css: [...CSS_BY_NAME.values()].join('\n')
  })
}

/**
 * Get only the html string from a renderer function
 * @param   {Function} options.getHTML - function getting the component html
 * @param   {Function} options.dispose - teardown function
 * @returns {string} component html
 */
const getOnlyHTMLFromRenderer = ({getHTML, dispose}) => {
  const html = getHTML();
  dispose();
  return html
};

/**
 * Get only the html string from a renderer function
 * @param   {Function} options.getHTML - function getting the component html
 * @param   {Function} options.dispose - teardown function
 * @param   {string} options.css - component css
 * @returns {Object} {html, css} html and css of the rendered component
 */
const getFragmentsFromRenderer = ({getHTML, dispose, css}) => {
  const html = getHTML();
  dispose();
  return {html, css}
};

/**
 * Async component rendering implementation
 * @param   {Function} renderer - rendering function
 * @param   {Object} rendererPayload - renderer function payload argument
 * @returns {Promise} value of the renderer function
 */
const renderComponentAsync = curry__default['default']((renderer, rendererPayload) => {
  const {element} = rendererPayload;

  if (!element.onAsyncRendering)
    throw new Error('Please provide the onAsyncRendering callback to SSR asynchronously your components')

  const promise = new Promise((resolve, reject) => {
    const ret = element.onAsyncRendering(resolve, reject);

    if (ret && ret.then) {
      ret.then(resolve, reject);
    }
  });

  return Promise.race([
    promise.then(() => renderer(rendererPayload)),
    new Promise((resolve, reject) => {
      setTimeout(function() {
        reject(new Error(`Timeout error:: the component "${element.name}" didn't resolve the "onAsyncRendering" promise during the rendering process`));
      }, asyncRenderTimeout);
    })
  ])
});

const asyncRenderTimeout = 3000;
const renderAsync = curry__default['default'](createRenderer)(renderComponentAsync(getOnlyHTMLFromRenderer));
const renderAsyncFragments = curry__default['default'](createRenderer)(renderComponentAsync(getFragmentsFromRenderer));
const fragments = curry__default['default'](createRenderer)(getFragmentsFromRenderer);
const render = curry__default['default'](createRenderer)(getOnlyHTMLFromRenderer);

exports.asyncRenderTimeout = asyncRenderTimeout;
exports.default = render;
exports.fragments = fragments;
exports.render = render;
exports.renderAsync = renderAsync;
exports.renderAsyncFragments = renderAsyncFragments;
